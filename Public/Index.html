<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Rocket League Mini — Online</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
  html,body{margin:0;background:#0b1020;color:#e8eefc;font-family:system-ui}
  #wrap{display:flex;flex-direction:column;align-items:center;padding:12px;gap:10px}
  #top{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:center}
  input,button{border-radius:10px;border:1px solid rgba(255,255,255,.18);background:#0a1e3b;color:#e8eefc;padding:10px 12px;font-weight:700}
  input{width:140px}
  #status{opacity:.85;font-weight:700}
  #stage{position:relative}
  canvas{background:#061018;border-radius:12px;border:1px solid rgba(255,255,255,.15)}
  #countdown{
    position:absolute; inset:0;
    display:flex; align-items:center; justify-content:center;
    font-weight:900; font-size:110px;
    letter-spacing:2px;
    text-shadow:0 12px 40px rgba(0,0,0,.65);
    pointer-events:none; opacity:0;
    transition:opacity .15s;
  }
  #hint{max-width:980px;opacity:.8;font-size:14px;line-height:1.35;text-align:center}
</style>
</head>
<body>
<div id="wrap">
  <div id="top">
    <button id="createBtn">Create room</button>
    <input id="code" placeholder="ROOM CODE" maxlength="5" />
    <button id="joinBtn">Join room</button>
    <span id="status">Not connected</span>
  </div>

  <div id="stage">
    <canvas id="c" width="980" height="560"></canvas>
    <div id="countdown"></div>
  </div>

  <div id="hint">
    Controls: <b>W</b>/<b>S</b> accelerate brake+reverse, <b>A</b>/<b>D</b> steer, <b>Space</b> drift, <b>Shift</b> boost. Controller still works too.
    <br>Player 1 is blue. Player 2 is red. Share the page link + room code.
  </div>
</div>

<script>
(() => {
  const createBtn = document.getElementById("createBtn");
  const joinBtn = document.getElementById("joinBtn");
  const codeEl = document.getElementById("code");
  const statusEl = document.getElementById("status");
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");
  const countdownEl = document.getElementById("countdown");

  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));

  // ---------- Networking ----------
  const wsUrl = (location.protocol === "https:" ? "wss://" : "ws://") + location.host;
  let ws = null;
  let roomCode = "";
  let seat = "";

  function setStatus(s){ statusEl.textContent = s; }

  function connect() {
    if (ws && (ws.readyState === 0 || ws.readyState === 1)) return;

    ws = new WebSocket(wsUrl);
    ws.onopen = () => setStatus("Connected. Create or join a room.");
    ws.onclose = () => setStatus("Disconnected.");
    ws.onerror = () => setStatus("WebSocket error.");
    ws.onmessage = (e) => {
      const msg = JSON.parse(e.data);
      if (msg.type === "room") {
        roomCode = msg.code;
        seat = msg.seat;
        codeEl.value = roomCode;
        setStatus(`In room ${roomCode} as ${seat.toUpperCase()}`);
      } else if (msg.type === "err") {
        setStatus("Error: " + msg.msg);
      } else if (msg.type === "state") {
        lastSnap = msg.snap;
      }
    };
  }

  connect();

  createBtn.onclick = () => {
    connect();
    ws.send(JSON.stringify({ type: "create" }));
    setStatus("Creating room…");
  };

  joinBtn.onclick = () => {
    connect();
    const c = codeEl.value.trim().toUpperCase();
    if (!c) return setStatus("Enter a room code.");
    ws.send(JSON.stringify({ type: "join", code: c }));
    setStatus("Joining room…");
  };

  // ---------- Input ----------
  const keyDown = new Set();
  window.addEventListener("keydown", (e)=>{ keyDown.add(e.code); if(e.code==="Space") e.preventDefault(); }, {passive:false});
  window.addEventListener("keyup",   (e)=>{ keyDown.delete(e.code); if(e.code==="Space") e.preventDefault(); }, {passive:false});

  function readKeyboard(){
    const left  = keyDown.has("KeyA") ? 1 : 0;
    const right = keyDown.has("KeyD") ? 1 : 0;
    const steer = clamp(right - left, -1, 1);

    const accel = keyDown.has("KeyW");
    const brake = keyDown.has("KeyS");
    const boost = keyDown.has("ShiftLeft") || keyDown.has("ShiftRight");
    const drift = keyDown.has("Space");

    return { steer, accel, accelAmt: accel?1:0, brake, brakeAmt: brake?1:0, drift, boost };
  }

  function readGamepad(){
    const p = navigator.getGamepads?.()[0];
    if(!p) return null;

    const dz=0.14;
    const lx=p.axes[0] ?? 0;
    let steer = Math.abs(lx)<dz ? 0 : lx;
    steer = Math.sign(steer) * (Math.abs(steer) ** 0.5);

    const rt = p.buttons[7]?.value ?? 0;           // accelerate
    const lt = p.buttons[6]?.value ?? 0;           // brake/reverse
    const drift = p.buttons[2]?.pressed ?? false;  // square
    const boost = p.buttons[5]?.pressed ?? false;  // R1

    return {
      steer: clamp(steer,-1,1),
      accel: rt>0.10, accelAmt: clamp(rt,0,1),
      brake: lt>0.10, brakeAmt: clamp(lt,0,1),
      drift, boost
    };
  }

  function getInput(){
    const kb = readKeyboard();
    const gp = readGamepad();
    if(!gp) return kb;

    const gpActive =
      Math.abs(gp.steer)>0.02 || gp.accel || gp.brake || gp.boost || gp.drift ||
      gp.accelAmt>0.05 || gp.brakeAmt>0.05;

    return gpActive ? gp : kb;
  }

  // Send inputs ~60Hz
  let lastInputSend = 0;
  function sendInput(t){
    if(!ws || ws.readyState !== 1 || !roomCode) return;
    if(t - lastInputSend < 16) return;
    lastInputSend = t;

    const i = getInput();
    ws.send(JSON.stringify({ type: "input", i }));
  }

  // ---------- Rendering ----------
  let lastSnap = null;

  function countdownColour(kickoffTimer){
    if(kickoffTimer > 0){
      const n = Math.ceil(kickoffTimer);
      if(n >= 5) return "rgba(255, 213, 74, 0.98)";
      if(n === 4) return "rgba(255, 138, 61, 0.98)";
      if(n === 3) return "rgba(255, 59, 59, 0.98)";
      return "rgba(73, 230, 140, 0.98)";
    }
    return "rgba(73, 230, 140, 0.98)";
  }

  function roundRectFill(x,y,w,h,r){
    r = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y, x+w,y+h, r);
    ctx.arcTo(x+w,y+h, x,y+h, r);
    ctx.arcTo(x,y+h, x,y, r);
    ctx.arcTo(x,y, x+w,y, r);
    ctx.closePath();
    ctx.fill();
  }

  function drawCar(car, color){
    ctx.save();
    ctx.translate(car.x, car.y);
    ctx.rotate(car.a);

    const L = 38, Wc = 22;
    const rear = -L/2, front = L/2;
    const halfW = Wc/2;
    const noseR = 10;

    ctx.beginPath();
    ctx.moveTo(rear, -halfW);
    ctx.lineTo(rear,  halfW);
    ctx.lineTo(front - noseR,  halfW);
    ctx.arc(front - noseR, halfW - noseR, noseR, Math.PI/2, 0, true);
    ctx.arc(front - noseR, -halfW + noseR, noseR, 0, -Math.PI/2, true);
    ctx.closePath();

    ctx.fillStyle = color;
    ctx.fill();
    ctx.strokeStyle = "rgba(0,0,0,0.38)";
    ctx.lineWidth = 2;
    ctx.stroke();

    // Wheels
    ctx.fillStyle = "rgba(8,8,8,0.95)";
    const wheelR = 4, wheelXFront = 10, wheelXRear = -10, wheelYOffset = halfW + 2;
    ctx.beginPath(); ctx.arc(wheelXFront, -wheelYOffset, wheelR, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(wheelXFront,  wheelYOffset, wheelR, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(wheelXRear,  -wheelYOffset, wheelR, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(wheelXRear,   wheelYOffset, wheelR, 0, Math.PI*2); ctx.fill();

    // Direction line
    ctx.strokeStyle = "rgba(255,255,255,0.9)";
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(front,0); ctx.stroke();

    ctx.restore();
  }

  function drawBall(b){
    ctx.save();
    ctx.translate(b.x, b.y);

    ctx.fillStyle = "rgba(255,255,255,0.96)";
    ctx.beginPath(); ctx.arc(0, 0, 25, 0, Math.PI*2); ctx.fill();

    // simple rolling stripes
    ctx.save();
    ctx.beginPath(); ctx.arc(0,0,25,0,Math.PI*2); ctx.clip();
    ctx.rotate(b.spin || 0);
    ctx.globalAlpha = 0.22;
    ctx.fillStyle = "#000";
    for(let x=-60;x<=60;x+=22) ctx.fillRect(x,-60,10,120);
    ctx.restore();

    ctx.restore();
  }

  function draw(s){
    const field = s.field;
    const UI_TOP=44, UI_BOTTOM=56, UI_SIDE=40;

    ctx.clearRect(0,0,980,560);

    // pitch stripes
    ctx.fillStyle="#0b3b1b";
    ctx.fillRect(field.l, field.t, field.r-field.l, field.b-field.t);
    const stripeCount=10;
    const sw=(field.r-field.l)/stripeCount;
    for(let i=0;i<stripeCount;i++){
      ctx.fillStyle=(i%2===0)?"#0e4a23":"#0c3f1f";
      ctx.fillRect(field.l+i*sw, field.t, sw, field.b-field.t);
    }

    // lines
    ctx.save();
    ctx.strokeStyle="rgba(255,255,255,0.78)"; ctx.lineWidth=3;
    ctx.strokeRect(field.l, field.t, field.r-field.l, field.b-field.t);

    ctx.strokeStyle="rgba(255,255,255,0.55)"; ctx.lineWidth=2;
    ctx.beginPath(); ctx.moveTo(field.mx, field.t); ctx.lineTo(field.mx, field.b); ctx.stroke();
    ctx.beginPath(); ctx.arc(field.mx, field.my, 82, 0, Math.PI*2); ctx.stroke();

    ctx.strokeStyle="rgba(255,255,255,0.75)"; ctx.lineWidth=3;
    ctx.strokeRect(field.l - s.goal.d, field.my - s.goal.w/2, s.goal.d, s.goal.w);
    ctx.strokeRect(field.r,            field.my - s.goal.w/2, s.goal.d, s.goal.w);
    ctx.restore();

    // pads
    ctx.save();
    const flick = (Math.floor((s.t/1000)*10) % 2) === 0;
    for(const p of s.pads){
      const active = (p.t <= 0.001);
      if(active){
        const ring = flick ? "rgba(255, 211, 77, 0.98)" : "rgba(255, 140, 64, 0.98)";
        const fill = flick ? "rgba(255, 211, 77, 0.35)" : "rgba(255, 140, 64, 0.35)";
        ctx.lineWidth=3; ctx.strokeStyle=ring;
        ctx.beginPath(); ctx.arc(p.x,p.y,14+3,0,Math.PI*2); ctx.stroke();
        ctx.fillStyle=fill;
        ctx.beginPath(); ctx.arc(p.x,p.y,14-2,0,Math.PI*2); ctx.fill();
      } else {
        ctx.globalAlpha=0.2;
        ctx.lineWidth=2; ctx.strokeStyle="rgba(180,210,255,0.95)";
        ctx.beginPath(); ctx.arc(p.x,p.y,14+2,0,Math.PI*2); ctx.stroke();
        ctx.globalAlpha=1;
      }
    }
    ctx.restore();

    // entities
    drawBall(s.ball);
    drawCar(s.blue, "#2fb8ff");
    drawCar(s.red,  "#ff5454");

    // UI bars
    ctx.fillStyle="#0a1e3b";
    ctx.fillRect(0,0,980,UI_TOP);
    ctx.fillRect(0,560-UI_BOTTOM,980,UI_BOTTOM);

    // score
    ctx.font="800 22px system-ui";
    ctx.fillStyle="rgba(255,255,255,0.95)";
    ctx.textAlign="center"; ctx.textBaseline="middle";
    ctx.fillText(`${s.scoreL}  -  ${s.scoreR}`, 980/2, UI_TOP/2 + 1);

    // boost (only show your own)
    const me = (seat === "p2") ? s.red : s.blue;
    const bx=18, by=560-UI_BOTTOM+14, bw=240, bh=18;
    ctx.font="700 14px system-ui";
    ctx.fillStyle="rgba(255,255,255,0.9)";
    ctx.textAlign="left"; ctx.textBaseline="bottom";
    ctx.fillText("BOOST", bx, by-4);

    ctx.globalAlpha=0.95;
    ctx.fillStyle="rgba(255,255,255,0.14)";
    roundRectFill(bx,by,bw,bh,10);

    const pct=clamp(me.boost,0,100)/100;
    if(pct>0){
      const g=ctx.createLinearGradient(bx,0,bx+bw,0);
      g.addColorStop(0.0,"#ffd54a"); g.addColorStop(0.6,"#ff8a3d"); g.addColorStop(1.0,"#ff3b3b");
      ctx.fillStyle=g;
      roundRectFill(bx,by,bw*pct,bh,10);
    }

    // countdown overlay
    if(s.kickoffActive){
      countdownEl.style.opacity = 1;
      countdownEl.style.color = countdownColour(s.kickoffTimer);
      countdownEl.textContent = s.kickoffTimer > 0 ? String(Math.ceil(s.kickoffTimer)) : "GO";
    } else {
      countdownEl.style.opacity = 0;
      countdownEl.textContent = "";
    }
  }

  function loop(t){
    sendInput(t);
    if(lastSnap) draw(lastSnap);
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
